#!/bin/bash

# Pre-commit hook to run static checks in parallel


#########################################################################
####        Add Additional Chekc:                                    ####
####    A: Add a new name (lowercase) to the CHECK_NAMES array       ####
####    B: Add an tuple in the CHECK_COMMANDS array                  ####
####         KEY = Name you added to CHECK_NAMES                     ####
####         VALUE = Command to run for that check                   ####
#########################################################################


# Define checks: name and command
# To add a new check: add "name" to CHECK_NAMES and add CHECK_COMMANDS[name]="command"
# It mosy be a single-word name (lowercase) for display and mapping purposes, but the command can be anything you want
# To disable a check: remove the name from CHECK_NAMES (doesn't need removal from CHECK_COMMANDS)
CHECK_NAMES=("cspell" "markdownlint")

# Mapping of names (above) to their respective commands
declare -A CHECK_COMMANDS=(
    [cspell]="cspell"
    [markdownlint]="markdownlint-cli2"
    [build]="bundle exec rake jekyll:build" 
    [externallinks]="bundle exec rake proofer:check"
    [internallinks]="bundle exec rake proofer:dev"
)

# Mapping for display names (optional) No entry means it will just capitalize the name from CHECK_NAMES
declare -A DISPLAY_NAMES=(
    [externallinks]="External links"
    [internallinks]="Internal links"
)

####################################################
####                 DANGER ZONE:               ####
####     No need to edit below this point       ####
####     unless you know what you're doing!     ####
####################################################

# Function to capitalize first letter
capitalize() {
    echo "$1" | sed 's/^./\U&/'
}

# Function to get display name for a check
get_display_name() {
    local name=$1
    if [ -n "${DISPLAY_NAMES[$name]}" ]; then
        echo "${DISPLAY_NAMES[$name]}"
    else
        capitalize "$name"
    fi
}

# Function to mark all checks as pending in GitHub Actions
mark_pending_statuses() {
    gh extension install lakruzz/gh-set-status

    for check in "${CHECK_NAMES[@]}"; do
        gh set-status pending "$(get_display_name $check) check" "precommit:$check"
    done
}

# Function to start a check in the background
run_check() {
    local name=$1
    
    printf "   ‚è≥ $(get_display_name $name) check\n"
    ((PROGRESS_COUNT++))
    eval "${CHECK_COMMANDS[$name]}" > "${CHECK_OUT[$name]}" 2>&1 &
    CHECK_PID[$name]=$!
}

# Function to wait for and capture exit status
wait_check() {
    local name=$1
    
    wait "${CHECK_PID[$name]}" || CHECK_STATUS[$name]=$?
}

# Function to print status line
print_status() {
    local name=$1
    
    if [ "${CHECK_STATUS[$name]}" -eq 0 ]; then
        echo "   ‚úÖ $(get_display_name $name) check"
    else
        echo "   ‚ùå $(get_display_name $name) check"
    fi

    # Be more verbose in GitHub Actions and set the status for each check
    if [ "$GITHUB_ACTION_RUN" -eq 1 ]; then
        if [ "${CHECK_STATUS[$name]}" -eq 0 ]; then
            gh set-status success "$(get_display_name $name) check passed" "precommit:$name"
            echo "   $(get_display_name $name) check passed" >> $GITHUB_STEP_SUMMARY
        else
            gh set-status failure "$(get_display_name $name) check failed" "precommit:$name"
            echo "   $(get_display_name $name) check failed" >> $GITHUB_STEP_SUMMARY
        fi
    fi  
}

# Function to display error output
show_error() {
    local name=$1
    
    if [ "${CHECK_STATUS[$name]}" -ne 0 ]; then
        echo "$(get_display_name $name) issues:"
        cat "${CHECK_OUT[$name]}"
        echo ""
    fi
    # Be more verbose in GitHub Actions and show check output in summary
    if [ "$GITHUB_ACTION_RUN" -eq 1 ]; then
        if [ "${CHECK_STATUS[$name]}" -ne 0 ]; then
            echo "   $(get_display_name $name) check output:" >> $GITHUB_STEP_SUMMARY
            cat "${CHECK_OUT[$name]}" >> $GITHUB_STEP_SUMMARY
        fi
    fi

}

# Function to run a phase of checks in parallel
run_checks_phase() {
    local -n check_array=$1
    
    # Start all checks in parallel
    for check in "${check_array[@]}"; do
        run_check "$check"
    done

    # Wait for all checks to complete
    for check in "${check_array[@]}"; do
        wait_check "$check"
        if [ "${CHECK_STATUS[$check]}" -ne 0 ]; then
            PASS=FALSE
        fi
    done

    # Clear progress lines and replace with results
    for ((i=0; i<PROGRESS_COUNT; i++)); do
        tput cuu 1  # Move cursor up one line
        tput el     # Clear line
    done

    # Print final status for each check
    for check in "${check_array[@]}"; do
        print_status "$check"
    done
}

# Main execution
if [[ -z "$GITHUB_REPOSITORY" || -z "$GITHUB_SHA" || -z "$GITHUB_ACTION" || -z "$GITHUB_RUN_ID" || -z "$GITHUB_SERVER_URL" ]]; then
    GITHUB_ACTION_RUN=0
else
    GITHUB_ACTION_RUN=1
fi

SUBCOMMAND="$1"

if [ -n "$SUBCOMMAND" ]; then
    if [ "$SUBCOMMAND" != "mark-pending" ]; then
        echo "‚ùå Unknown subcommand: $SUBCOMMAND"
        echo ""
        echo "Supported subcommand: mark-pending"
        echo "Usage: pre-commit [mark-pending]"
        echo "  The 'mark-pending' subcommand is used in GitHub Actions to mark"
        echo "  all checks with status 'pending' before they run."
        echo "  The subcommand will fail if run outside of GitHub Actions."
        exit 1
    fi

    if [ "$GITHUB_ACTION_RUN" -ne 1 ]; then
        echo "Subcommand 'mark-pending' is only valid in GitHub Actions runs"
        exit 1
    fi

    mark_pending_statuses
    exit 0
fi

PASS=TRUE

# Create local temp directory for output capture
TMPDIR=".tmp"
if [ ! -d "$TMPDIR" ]; then
    mkdir -p "$TMPDIR"
    echo "*" > "$TMPDIR/.gitignore"
fi

# Create temp files and declare arrays
declare -A CHECK_OUT
declare -A CHECK_PID
declare -A CHECK_STATUS

for check in "${CHECK_NAMES[@]}"; do
    CHECK_OUT[$check]=$(mktemp -p "$TMPDIR")
    CHECK_STATUS[$check]=0
done

# Cleanup temp files on exit
trap 'rm -f "${CHECK_OUT[@]}"' EXIT

echo "üîç Running checks in parallel..."

# Track how many progress lines we print
PROGRESS_COUNT=0

# Phase 1: Run build and basic checks
run_checks_phase CHECK_NAMES

# Report results
if [ "$PASS" == "TRUE" ]; then
    echo ""
    echo "‚úÖ All pre-commit checks passed"
    exit 0
else
    echo ""
    for check in "${CHECK_NAMES[@]}"; do
        show_error "$check"
    done
    
    echo "üëâ Fix the issues above before committing."
    echo "üí° You can run the same checks manually with: '.githooks/pre-commit'"
    exit 1
fi
